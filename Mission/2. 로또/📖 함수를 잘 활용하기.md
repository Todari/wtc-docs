
# 연습 문제

## #1

호출할 때마다 현재 게임 카운트를 올려주는 함수를 만들고 싶다. 어떻게 만들 수 있을까?

```javascript
countGameRound(); // 1
countGameRound(); // 2
countGameRound(); // 3
```

### 구현 예시

```javascript
const createRoundCounter = () => {
    let round = 0;

    return () => round += 1;
}

const countGameRound = createRoundCounter();

console.log(countGameRound());
```

## #2

미국 지사에서도 로또 프로그램을 쓰고 싶다고 연락이 왔다. 미국의 파워볼은 1~69사이의 숫자 5개 + 1~26 사이의 숫자 1개(파워볼)를 맞춰야 하는 규칙을 가지고 있다. 특정 범위의 숫자 중 랜덤으로, 중복되지 않는 숫자 n개를 뽑는 기능이 중복되는 것 같다. 어떻게 중복을 제거할 수 있을까?

```javascript
const generateLotto = () => {
  const lottoNumbers = new Array(45).fill().map((_, index) => index + 1);
  lottoNumbers.sort(() => Math.random() - 0.5);

  return lottoNumbers.slice(0, 6);
};

const generatePowerBall = () => {
  const lottoNumbers = new Array(69).fill().map((_, index) => index + 1);
  lottoNumbers.sort(() => Math.random() - 0.5);

  return lottoNumbers.slice(0, 5);
};
```

### 구현 예시

```javascript
const createLottoGenerator = (maxNumber, count) => {
    const numbers = new Array(maxNumber).fill().map((_, index) => index + 1);

    return () => {
        numbers.sort(() => Math.random() - 0.5);
        return numbers.slice(0, count);
    }
};

const generateLotto = createLottoGenerator(45, 6);
const generatePowerBall = createLottoGenerator(69, 5);

const lottoNumbers = generateLotto();
const powerBallNumbers = generatePowerBall();
```

# 언어를 깊이 있게 학습하고 잘 활용한다는 것은?

> 레벨1 학습 목표: JavaScript/TypeScript 언어의 주요 문법들을 깊이 있게 학습한다.

## JavaScript는

- 멀티 패러다임 프로그래밍 언어
    - 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원
- 일반적인 호스트 환경은 브라우저이지만, 서버 사이드, 데스크탑 앱 등 점차 다양한 호스트 환경에서 사용되고 있음
- 함수 역시 하나의 객체

### 필요에 따라 객체 지향도 함수형도 활용한다.

- 꼭 (class 기반의) 객체 지향을 지향하지 않아도 된다. 필요한 곳에만 적절히 활용한다.
- 필요에 맞다면 함수를 적극적으로 활용한다.
- 모든 경우에 통하는 정답은 없다. 어떨 때 객체를 활용하고, 어떨 때 함수를 활용할 지 스스로 생각하는 기준에 대해 고민해본다.

##   

# 함수에서 시작하기

- class, 없어도 된다.
- 요구 사항으로부터 객체를 설계하는 방식이 익숙하지 않거나 어렵다면, 일단 기능 단위의 함수부터 만들어보고 점진적으로 리팩터링한다.
- 일단 구현한다 -> 구현한 기능만큼에 대해 테스트를 추가한다 -> 리팩터링한다
- ex) 일단 로또 등수 구하는 함수를 되는대로 쓴다 -> 1등~5등까지에 대한 테스트 케이스를 작성한다. -> 리팩터링한다. 이 과정에서 객체로 묶을 게 있다면 묶는다. -> 테스트 케이스도 리팩터링한다 -> 반복

```javascript
// 로또 하나의 등수를 구한다.
const getRank = (lottoNumbers, winningLottoNumbers, bonusNumber) => {
  const matchedCount = lottoNumbers.filter((number) => winningLottoNumbers.has(number)).length;
  const hasBonus = lottoNumbers.has(bonusNumber);

  if (matchedCount === 6) {
    return 1;
  }

  if (matchedCount === 5 && hasBonus) {
    return 2;
  }

  if (matchedCount === 5) {
    return 3;
  }

  if (matchedCount === 4) {
    return 4;
  }

  if (matchedCount === 3) {
    return 5;
  }

  return 0;
};
```

  

# 함수의 특성 이해하기

## 일급 함수

- JS에서 함수는 일급 객체

### 고차 함수(high-order function)

- 다른 함수를 인자로 받거나, 함수를 리턴하는 함수를 만들 수 있다.
- 이름이 어려워보이지만 이미 이전 미션부터 사용해보았던 방식
    - callback
    - 다양한 배열 내장 메서드

```javascript
const ranks = lottos.map((lotto) => match(lotto, winningLotto));

const firstRanks = ranks.filter((rank) => rank === 1)

const hasOverMaxNumber = numbers.some((number) => number > MAX_NUMBER)
```

### 클로저(Closure)

- 함수의 private state가 필요하다면 클로저를 활용한다.
    - 아래 예시에서는 1~45까지의 숫자를 담은 배열을 로또 번호를 생성할 때마다 매번 새로 만들지 않고 재활용할 수 있다.

```javascript
const createRandomGenerator = () => {
  const lottoNumbers = new Array(45).fill().map((_, index) => index + 1);

  return () => {
    lottoNumbers.sort(() => Math.random() - 0.5);
    return lottoNumbers.slice(0, 6);
  };
};
```

- 반드시 클로저를 사용해야 하거나, 클로저를 사용한 코드가 무조건 더 좋은 것은 아니다. 어떤 경우에 활용하는 게 좋을지 스스로의 생각과 기준을 고민해본다.

### 화살표 함수(arrow function)

- 함수 본문이 간단한 return문만 포함할 때에는 화살표 함수 문법을 사용하면 간결하게 작성할 수 있다.
- 고차 함수처럼 함수를 인자로 전달해야 하는 경우, 간단한 return문만 포함하는 함수라면 화살표 함수를 활용한다.
    - 함수가 정의된 스코프의 this를 사용하기 때문에, 함수를 다른 곳으로 전달할 때에 this에 대한 혼란을 줄일 수 있다.
    - 익명 함수로 전달하거나, 가독성이 고민되는 경우 간단하더라도 이해를 돕기 위해 이름을 붙여 활용한다.

```javascript
function shuffle(array) {
    return array.sort(() => Math.random() - 0.5)
}
// vs
const shuffle = (array) => array.sort(() => Math.random() - 0.5);
```
  

# 함수형 생각 연습

좋은 코드의 특성으로 아래와 같은 것들을 이야기했었다.

- 예측 가능하다
- 실수를 방지해준다
- 읽기 쉽다
- 테스트하기 쉽다

함수형으로 생각해보기 위한 지침들이 이 특성들과 어떻게 연결되는지 살펴보자.  
('함수형 프로그래밍'이라고 생각하면 여러 복잡하고 어려운 개념들과 마주할 수 있다. 우선은 다음 3가지에 대해서만 먼저 생각해본다.)

## 1. 가능하면 순수 함수(pure function)로 작성한다.

- 함수의 파라미터가 함수의 input을 제공하고, 주어진 이 input에 의해서만 output이 결정되도록 만든다.
    - 이러한 함수를 부수 효과가 없는, 순수 함수 라고 부른다.

```javascript
// not pure
const numbers = [1, 2, 3, 4, 5]; 

function shuffle() {
    return numbers.sort(() => Math.random() - 0.5);
}
```

```javascript
// pure
function shuffle(numbers) {
    return numbers.sort(() => Math.random() - 0.5);
}
```

- 하지만 순수 함수로만 어플리케이션을 만들 수는 없다.
    - 아래와 같은 동작은 중요한 부수 효과들로 대부분의 어플리케이션에서 반드시 필요한 동작이다.
        - 브라우저에서의 이벤트 처리
        - 화면에 출력
        - API 통신
        - 웹 API를 사용하는 코드
        - 데이터베이스 읽기/쓰기

### 순수 함수(pure function)와 부수 효과(side effect)가 있는 함수를 구분한다.

- 순수 함수는 동작을 예측하기 쉽다. 주어진 input이 같다면 항상 같은 output을 기대할 수 있기 때문이다.
- 순수 함수는 테스트하기 쉽다. 함수 외부의 요소에 의존하는 것이 없으며, input과 output이 명확하다.
- 테스트하기 어려운 랜덤과 같은 요소들을 분리해냈듯이, 부수 효과가 있는 함수들은 가능한 부수 효과를 위해서만 동작할 수 있도록 따로 구분한다.  
      
    

## 2. 데이터를 불변으로 유지한다.

- 의도하지 않게 데이터가 변경되는 일을 막을 수 있다.

### 변수를 선언할 때에는 const를 활용한다.

- 가능하다면 let 대신 const를 사용하는 것을 지향합니다.
- let을 const로 바꿀 수 없을 지 고민해보세요. 이렇게 바꾸려고 하다보면 높은 확률로
    - 함수를 분리하게 됩니다.
    - 명령형 방식으로 되어있는 코드를 대체할 방법을 고민하게 됩니다.
- 생각해보기) const 로 선언하면 항상 불변을 유지할 수 있나?

### 값을 변경할 때에는 복사본을 만들어 활용한다.

- 원본 데이터를 직접 조작하는 경우, 의도하지 않은 버그를 만들어내기가 쉽다. 이런 경우 앱의 규모가 커질수록 디버깅도 쉽지 않을 수 있다.

``` javascript
const numbers = [1, 3, 5, 4, 2];

// 1)
const sortNumbers = (numbers) => {
    return numbers.sort((a, b) => a - b);
}

console.log(numbers); // ?

// 2) 
const sortNumbers = (numbers) => {
    return [...numbers].sort((a, b) => a - b);
}

console.log(numbers); // ?
```

- 어딘가에서 `numbers`를 사용하고 있었고, 정렬되지 않은 그대로 있을 거라 가정하고 쓰고 있었다면?

##   

**복사본 만들기**

- 배열의 `slice()` 메서드 활용

```javascript
const copied = numbers.slice();
```

- 객체의 `Object.assign()` 메서드 활용

```javascript
const copied = Object.assign({}, object)
```

- `전개 연산자(spread operator)` 활용

```javascript
const copied = [...numbers];
```

##   

## 3. 선언형 코드를 지향한다.

- 구체적인 구현 방식을 드러내기보다, 어떤 동작을 해야하는 지를 더 명시적으로 읽을 수 있게 해주기 때문에 코드 가독성을 높여 준다.
- 함수로 분리하고 함수의 이름으로 어떤 동작을 하는지를 드러낸다.
- 함수를 인자로 넘겨줄 때도 필요하다면 기명함수로 만들어 가독성을 높인다. 한 줄짜리 코드더라도 어떤 역할인지 이해하고 추측하는 데에 시간을 쓰게 하는 것보다 이름을 붙여주는 게 이해하기 쉬운 코드일 수 있다.

```javascript
array.sort(() => Math.random() - 0.5);
// vs 
shuffle
```

- 자동차 경주 피드백의 '내장 메서드 잘 활용하기'도 다시 참고해보세요.

##   

## +) 참고해보기

### 함수 조합 (function composition)

- 여러 개의 작은 함수를 조합해 필요한 함수를 만들어 사용할 수도 있다.
- '선언형 코드를 지향한다'에서와 같이 보다 명시적으로 어떤 동작인지를 드러낼 수 있다.
    - 다만 지나칠 경우, 팀 내에서 잘 사용하지 않는 방식인 경우 등에는 오히려 가독성을 떨어트릴 수도 있으니 주의한다.
```javascript
const numbers = new Array(45).fill().map((_, index) => index + 1);
const shuffle = (numbers) => [...numbers].sort(() => Math.random() - 0.5);
const take = (n) => (array) => array.slice(0, n);

const generateLottoNumbers = () => take(6)(shuffle(numbers));

const lottoNumbers = generateLottoNumbers();
```
# 🤔 생각해보기

- JavaScript 함수의 특성에는 어떤 것들이 있을까?
- 클로저란 무엇인지?
    - 일반적으로 함수는 기억력이 없다. 클로저는 어떻게 상태를 가질 수 있을까?
- 클로저는 또 어디에 활용할 수 있을까?

# 🔗 참고 자료

- [자바스크립트에서 객체지향을 하는 게 맞나요?](https://yozm.wishket.com/magazine/detail/1396/l/)
<iframe width="920" height="518" src="https://www.youtube.com/embed/e-5obm1G_FY" title="Learning Functional Programming with JavaScript - Anjana Vakil - JSUnconf" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<iframe width="920" height="518" src="https://www.youtube.com/embed/PJjPVfQO61o" title="[10분 테코톡] 꼬재의 클로저" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<iframe width="920" height="518" src="https://www.youtube.com/embed/EWfujNzSUmw" title="[10분 테코톡] 💙 하루의 실행 컨텍스트" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>