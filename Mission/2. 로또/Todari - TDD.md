
## About TDD
- 테스트 주도 개발(test-driven development)
- 선 테스트 후 개발 방식의 프로그래밍
- 자동화된 테스트 코드 작성 후 테스트를 통과하기 위한 코드를 개발하는 방식


## TDD를 이용한 개발방법
### 1. 테스트 케이스 작성
- 구현 예정인 기능과 그 요구사항을 점검할 테스트 코드 작성
- 해당 테스트가 실패하는지 확인
### 2. 테스트 케이스를 통과하는 코드 작성
- 테스트 코드를 통과할 기능 구현
- 단위테스트 통과 가능한 최소한의 코드 작성
- 테스트 성공을 위한 최소한의 코드 그 이상을 변경하거나 추가하면 안됨
- 테스트 코드가 테스트 하지는 이상의 코드를 작성하면, 다른 프로세스에 사이드이펙트 가능성
### 3. 작성한 코드 리팩토링
- 2.까지 진행한 코드를 재사용성, 가독성, 성능을 고려하여 개선
- 테스트 코드를 통해 구현한 코드를 반복하여 점검

## TDD 접근방법
### 1. 가짜로 구현
- 테스트를 빠르게 통과할 수 있는 가짜 구현(정답의 상수값 반환 등)을 통하여 우선 테스트 케이스를 통과
- 이후 그 값에 도달하기 위한 변수 조절

test
```javascript
test("add가 두 인자를 더한 값을 반환해야 한다.", () => {
  expect(add(1,3)).toEqual(4)
});
```
production - init
```javascript
const add = (a, b) => {
  return 4
}
```
production - modified
```javascript
const add = (a, b) => {
  return a + b
}
```
### 2. 삼각측량
- 테스트 주도를 통하여 추상화된 과정을 일반화
- 테스트 예시가 2개 이상인 경우 그 결과들을 이용
```javascript
test("add가 두 인자를 더한 값을 반환해야 한다.", () => {
  expect(add(1,3)).toEqual(4)
}); // true

test("add가 두 인자를 더한 값을 반환해야 한다.", () => {
  expect(add(2, 6)).toEqual(8)
}); // true

//then....
test("add가 두 인자를 더한 값을 반환해야 한다.", () => {
  expect(add(3, 7)).toEqual(10)
}); // true??
```
### 3. 명백하게 구현
- 1., 2.를 사용하지 않고 바로 정답을 구현
- 간단한 문제의 경우 명백하게 진짜 구현이 가능
```javascript
const add = (a, b) => {
  return a + b
}
```
## TDD 장점
### 1. 객체지향적인 코드 개발
- 단위 테스트를 포함한 테스트 코드를 먼저 작성 후 기능을 구현하므로, 모듈화가 쉽게 이루어짐
- 이에 따라 의존성과 종속성이 낮아질 수 밖에 없음
### 2. 설계 수정시간 단축
- 테스트 코드를 먼저 작성하므로 개발자가 현재 요구사항에 대해 분명히 알 수 있음
- 다양한 예외사항에 대해 생각하며 테스트 코드를 작성
- 코드를 새로 작성 혹은 수정하거나 기능을 추가할 경우 수시로 빠르게 검증이 가능
- 최초 설계대로 테스트 코드가 작성되기 때문에 여러 기능의 정의가 명확해짐
- 이를 통해 설계의 구조적 문제를 찾아내기 용이함
### 3. 리팩토링의 용이성
- 단위 테스트 기반의 테스트 코드로 인하여 각각의 모듈 별 테스트 진행이 가능
- 코드를 작성 및 수정하는 경우 수시로 테스트에 대한 피드백을 받을 수 있음
- 이로 인하여 리팩토링 시 안정성을 확보할 수 있음
### 4. 오버엔지니어링 예방
- 최초 기획한 설계 및 테스트 코드를 만족하는 최소한의 코드를 작성하며 진행하기 때문에 다른 곳에 영향을 줄 수 있는 오버엔지니어링의 가능성이 감소함

## TDD 단점
### 1. 생산성 저하
- 처음부터 테스트와 프로덕션 두가지의 코드를 작성하면서 진행하며 테스트를 수시로 진행
- 예외 발생 케이스가 분명한 경우 TDD를 사용하면 비효율적일 수 있음
- 이미 예외케이스를 인지하고 코드를 작성한다면 추후 발생할 예외케이스를 고려하여 두번이 아닌 한번에 작성할 수 있기 때문
### 2. 사전 준비 기간
- 익숙하지 않은 TDD 관련 지식을 습득하는데 소요되는 시간
- 모든 예외케이스를 구현된 것 없이 설계를 통해 생각해내고, 그에 따른 개발 진행을 하는 데 소요되는 시간

## FIRST 규칙
### Fast
테스트는 빠르게 동작하여 자주 돌릴 수 있어야 한디
### Independent
각 테스트는 독립적이고, 서로 의존하지 않아야 한다
### Repeatable
어느 환경에서도 반복할 수 있어야 한다
### Self-validating
테스트는 성공 혹은 실패로 결과를 내 자체적으로 검증되어야 한다
### Timely
테스트는 실제 코드 구현 직전에 구현해야 한다


## Opinion ..?
예외 케이스가 복잡하지 않은 경우엔 TDD의 도입이 생산성을 저하시킬 것
하지만 반대로, 예외케이스가 복잡하다면 그것도 그 나름대로 TDD 방식에 적응하고, 서로 의존하지 않는 다양한 모듈들의 예외케이스를 백지상태에서 설계하여 테스트코드를 작성할 수 있을까?
이 또한 많은 리소스의 소비가 필연적임

하지만 페어코딩 혹은 협업하는 상황이라면 오히려 TDD의 강점들이 효과적이라고 생각
백지에서 프로덕션코드를 쌓아 올라가는 경우는 각자 머리속의 설계가 달라 다양한 가지로 뻗을 수 있지만,
TDD를 통해 단위테스트를 진행할 모듈들과 예외사항을처음부터 설계한 뒤 그에 맞는 개발을 진행해 나간다면
팀원들이 나아가기 위한 방향을 정하기 쉬울 것이라고 생각
