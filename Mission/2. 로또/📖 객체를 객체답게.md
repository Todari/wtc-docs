
# 1. 객체 나누기 (모듈화)

## 역할, 책임, 협력

## '자율적'이고 '협력적'인 객체를 고민하기

- class, private, 객체지향의 여러 복잡한 원칙들 이전에, '왜' 그런 원칙들, 개념들이 나오게 되었을 지로 돌아가 보자.
- 우리의 목표는 '객체지향의 개념 학습 및 적용'이 아니라 -> '유지보수하기 좋은 코드'
    - 1. 파악하고 예측하기 쉽다
        
        - 해당 객체를 외부에서 사용할 때, 어떤 기능을 사용하면 되는 지 명확하게 파악할 수 있다.
    - 2. 새로운 기능을 추가하거나 수정하기 쉽다

![image.png](https://techcourse-storage.s3.ap-northeast-2.amazonaws.com/75d8d91478a448938a532fe2f8646e14)

> 협력 공동체의 일원으로서 객체는 다음과 같은 두 가지 덕목을 갖춰야 하며, 두 덕목 사이에서 균형을 유지해야 한다.
> 
> **첫째, 객체는 충분히 '협력적'이어야 한다.**  
> 외부의 도움을 무시한 채 모든 것을 스스로 처리하려고 하는 전지전능한 객체는 내부적인 복잡도에 의해 자멸하고 만다.
> 
> **둘째, 객체는 충분히 '자율적'이어야 한다.**  
> 객체 공동체에 속한 객체들은 공동의 목표를 달성하기 위해 협력에 참여하지만, 스스로의 결정과 판단에 따라 행동하는 자율적인 존재다.
> 
> 객체의 자율성은 객체의 내부와 외부를 명확하게 구분하는 것으로부터 나온다. 객체의 사적인 부분은 객체 스스로 관리하고 외부에서 간섭받지 않도록 차단하며, 객체의 외부에서는 객체가 스스로 허락한 수단을 통해서만 객체에 접근해야 한다. 객체는 다른 객체가 '무엇(what)'을 수행하는지는 알 수 있지만 '어떻게(how)' 수행하는지에 대해서는 알 수 없다.
> 
> <객체지향의 사실과 오해> 중에서

## 객체는 하나의 책임을 가지도록 한다.

- 한 가지 기능을 변경할 때에는 하나의 클래스(또는 객체)만 변경하도록 코드를 작성한다.

## 객체를 객체스럽게 사용한다.

- 밀접하게 연관된 데이터들은 객체 안에 캡슐화해서 다른 객체가 구현 세부 사항을 알지 못하도록 한다.
- 객체의 데이터를 직접 꺼내지 않고, 객체에 메시지를 던지도록 구조를 바꿔 데이터를 가지는 객체가 일하도록 한다.
- 참고) [getter를 사용하는 대신 객체에 메시지를 보내자](https://tecoble.techcourse.co.kr/post/2020-04-28-ask-instead-of-getter/)

## 적절한 자료구조를 활용한다.

- 요구 사항에 적합한 자료구조가 있다면 자료구조의 특성을 활용한다.

```javascript
if (numbers.length !== new Set(numbers).size) {
    throw new Error("로또 번호는 중복되지 않아야 합니다.");
}
```

# 2. 코드 재사용하기

## 상속(Inheritance) vs 조합(Composition)

- 객체들에서 중복 코드가 쓰이는 경우 상속, 조합 등의 방법으로 중복을 제거하고 코드를 재사용할 수 있다.

#### 중복 코드 발생

```javascript
class Lotto {
  constructor(numbers) {
    if (numbers.some((number) => number > MAX_NUMBER || number < MIN_NUMBER)) {
      throw new Error("로또 번호는 1~45 사이의 정수여야 합니다.");
    }

    if (numbers.length !== 6) {
      throw new Error("로또 번호는 6개여야 합니다.");
    }

    if (numbers.length !== new Set(numbers).size) {
      throw new Error("로또 번호는 중복되지 않아야 합니다.");
    }

    this.#numbers = numbers;
  }
}

class WinningLotto {
  constructor(numbers, bonusNumber) {
    if (numbers.some((number) => number > MAX_NUMBER || number < MIN_NUMBER)) {
      throw new Error("로또 번호는 1~45 사이의 정수여야 합니다.");
    }

    if (numbers.length !== 6) {
      throw new Error("로또 번호는 6개여야 합니다.");
    }

    if (numbers.length !== new Set(numbers).size) {
      throw new Error("로또 번호는 중복되지 않아야 합니다.");
    }

    if (numbers.includes(bonusNumber)) {
      throw new Error("보너스 번호는 당첨 번호와 중복될 수 없습니다.");
    }

    this.numbers = numbers;
    this.bonusNumber = bonusNumber;
  }
}
```

#### 상속

```javascript
class WinningLotto extends Lotto {
  constructor(numbers, bonusNumber) {
    super(numbers);

    if (numbers.includes(bonusNumber)) {
      throw new Error("보너스 번호는 당첨 번호와 중복될 수 없습니다.");
    }

    this.bonusNumber = bonusNumber;
  }
}

new WinningLotto([1,2,3,4,5,6], 7);
```

#### 조합

```javascript
class WinningLotto {
  constructor(winningLotto, bonusNumber) {
    if (winningLotto.has(bonusNumber)) {
      throw new Error("보너스 번호는 당첨 번호와 중복될 수 없습니다.");
    }

    this.winningLotto = winningLotto;
    this.bonusNumber = bonusNumber;
  }
}

new WinningLotto(new Lotto([1,2,3,4,5,6]), 7);
```

### 상속(Inheritance)보다 조합(Composition)을 활용한다.

- 단순히 재사용을 위해 상속을 사용하지 않는다.
- 참고) [상속보다는 조합(Composition)을 사용하자](https://tecoble.techcourse.co.kr/post/2020-05-18-inheritance-vs-composition/)

### 조합이 '항상' 더 좋은 선택지인 것은 아니다.

다음과 같이 명확한 의도가 있는 경우 상속을 사용한다.

- 명확하게 계층 구조를 표현해야 하는 경우
- 상위 클래스의 변경 사항이 하위 클래스로 전파되어도 문제가 없다는 것이 보장되는 경우

# 🤔 생각해보기

- 잘 모듈화한 코드는 어떤 특성을 가지고 있을까? 모듈화를 잘 하기 위한 본인만의 지침이 있는지?
- 객체 간에 로직을 재사용하기 위해 또 어떤 방법들을 사용할 수 있는지?

### JS 언어 개념 학습하기

- JS의 class와 같은 기능을 class 문법 없이 구현할 수 있을까?
- prototype은 어디에 활용할 수 있을까?
    - `const newArray = []` 이라고만 했을 뿐인데, Array에서 제공해주는 메서드들을 쓸 수 있는 이유 무엇인가?
    - [관련 키워드] 프로토타입 체인, `__proto__` 와 `prototype`