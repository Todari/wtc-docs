
# 🛡 실수를 방지해주는 코드

## 내장 메서드 잘 활용하기

- JS에서는 다양한 내장 메서드를 지원하고 있다. [Array](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array), [String](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String), [Object](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object) 등 표준 내장 객체들에서 지원하는 메서드들을 최대한 활용하여 코드의 실수를 줄이고 가독성을 개선할 수 있다.
- 예를 들어, String에서 제공하는 `repeat` 메서드를 활용할 수 있다.

```javascript
`${car.name}: ${"-".repeat(car.position)}` // 우택: --
```

### 반복문보다는 Array 내장 메서드 사용하기

- 일반적인 반복문에는 인덱스 카운팅할 변수, 조건, 인덱스를 어떻게 올릴지 까지 직접 입력하게 되어 있어 사람이 실수하기 쉬운 요소들이 많다.
- 아래와 같은 내장 메서드들이 어떤 역할을 하는 지 알아보자. 기존의 for문을 어떻게 바꿀 수 있을까?
    - forEach / map / join / reduce / some / every / includes / find / filter
    - [참고] 연습용 [codesandbox](https://codesandbox.io/s/js-naejang-meseodeu-hagseubhagi-moxy3?file=/src/__test__/array.test.js)
- 구현하려는 기능이 내장 메서드를 사용해서 해결할 수 있는지 확인해본다. 내장 메서드로 해결할 수 없는 경우에만 for 문을 사용한다.

### 명령형보다 선언형으로 작성한다.

- 선언형 프로그래밍은 결과를 얻기 위한 **과정을 상세히 명시**하는 대신, **원하는 결과**를 선언한다.
- 절차 반복문을 사용하기보다는 배열 내장 메서드를 사용하는 것 역시 원하는 결과를 얻기 위함이다.

```javascript
createCars(carNames) {
    let cars = [];

    for (let i = 0; i < carNames.length; i++) {
        cars.push(new Car(name));
    }

    return cars;
}

// -> map으로 바꾼다면
createCars(carNames) {
    return carNames.map((name) => new Car(name));
}
```

```javascript
isValidLengths(names) {
    for (let i = 0; i < names.length; i++) {
        if (names[i].length > 5) {
            return true;
        }
    }
    
    return false;
}

// -> every로 바꾼다면
isValidLengths(names) {
    return names.every((name) => name.length <= 5);
}
```

```javascript
convertArrayToString(array) {
  let string = '';
  array.forEach((item, index) => {
    if (index !== 0) {
      string += ',';
    }
    string += item;
  });
  return string;
}

const winners = ["준", "크론", "공원"];
const gameResult = convertArrayToString(winners); // 준,크론,공원

// -> join으로 바꾼다면
const winners = ["준", "크론", "공원"];
const gameResult = winners.join(","); // 준,크론,공원
```

마찬가지 방식으로 우승자를 구하는 로직을 아래와 같이 더 간결하게 작성할 수 있다.

```javascript
const determineWinners = (cars) => {
  const maxPosition = Math.max(...cars.map((car) => car.position)); // 전개 연산자에 대해 알아보세요
  const winners = cars.filter((car) => car.position === maxPosition).map((car) => car.name);

  return winners;
};
```

## 가능한 const로 개발하기

- 가능한 한 `let` 대신 `const`를 사용하여, 코드의 변경 가능성을 최소화한다. `const` 사용은 코드의 안정성을 높이고, 함수 분리나 선언적인 프로그래밍 스타일로의 전환을 유도한다.
- `let` 변수를 사용하고 수정하는 작업들은 대체로 명령형 방식일 확률이 높다. `let`을 `const`로 바꿀 수 있도록 고민해 본다. 이렇게 바꾸려고 하다보면 높은 확률로 **함수를 분리하게 되고 명령형 방식으로 되어있는 코드를 대체할 방법을 고민하게 된다.**

# 📦 모듈화

모듈화는 코드의 재사용성, 유지보수성을 높이고 복잡성을 낮추는 중요한 개념이다.

## JavaScript에서 객체를 만드는 다양한 방법을 이해하고 사용한다.

- JavaScript에서 객체를 만드는 방법은 다양하다. Class를 사용하지 않고도 객체를 만들 수 있으며, 상황에 따라 적절한 방법을 선택해야 한다.
- 가령, 모든 메서드가 static인 경우 class를 사용할 필요가 있을까?

```javascript
class Printer {
  static printTurn() { }
  static printGameResult() { }
  static printError(errorMessage) { }
}

// vs 

const printer = {
  printTurn() { },
  printGameResult() { },
  printError() { },
};

// vs 

printTurn() { }

printGameResult() { }

printError() { }
```

## 객체의 상태 접근을 제한한다.

- 객체의 상태를 캡슐화하고 외부에서 직접 접근하지 못하도록 제한한다. 이는 객체의 안정성을 높이고 예상치 못한 변경을 방지한다.

```javascript
class Car {
  #name;

  constructor(name) {
    this.#name = name;
  }
}
```

## 객체는 객체스럽게 사용한다.

- 객체 내의 데이터는 객체의 메서드를 통해 접근해야 하고 객체에 메시지를 던지는 방식으로 사용해야 한다. 데이터를 가지는 객체가 일하도록 한다.
    - (참고. [getter를 사용하는 대신 객체에 메시지를 보내자](https://tecoble.techcourse.co.kr/post/2020-04-28-ask-instead-of-getter/))

```javascript
class Car {
  #name;
  #position;

  constructor(name) {
    this.#name = name;
    this.#position = 0;
  }

  get position() {
    return this.#position;
  }
}

const car = new Car("name")
car.position += 1;
```

## 필드의 수를 줄이기 위해 노력한다

필드의 수가 많으면 객체가 복잡해지고, 관리가 어려워진다. 필요한 필드만 유지하고, 중복이나 불필요한 필드를 제거하여 객체의 복잡도를 낮춘다.

## 도메인 로직과 UI 로직을 분리한다

하나의 객체가 도메인 로직과 UI 로직을 모두 담당하기 보다는 적절히 분리하여 각각의 객체가 자신의 책임에 집중하도록 한다.

```javascript
class Car {
  static FORWARD_CONDITION = 4;
  #name;
  #position;

  constructor(name) {
    this.#name = name;
    this.#position = 0;
  }

  // 도메인
  move(condition) {
    if (condition < Car.FORWARD_CONDITION) {
      return;
    }

    this.#position += 1;
  }

  // UI
  printPosition() {
    console.log(`${this.#name}: ${this.#position}`)
  }
}
```

## util의 의미에 맞게 사용하기

- util은 보통 도메인과 관련 없는 범용적인 로직을 모아두는 곳이다. 범용성 있는 함수는 util로 분리하고, 도메인과 관련한 로직은 해당 도메인 모듈 내에 유지한다.
    - 1. 자동차 경주 게임과 상관없이 재사용할 수 있는, 범용성이 있는 함수는 util로 분리하는 것을 고려하기
    - 2. 반대로 '자동차 경주 게임'에 관련된 로직이 util에 있다면 다시 정리하기

# ✅ 테스트

> 테스트하기 쉬운 코드를 만들고, 제대로 테스트하기

## 테스트를 진행하기 전에...

- 테스트를 작성하는 이유에 대해 본인의 경험을 토대로 정리해 본다.
- 단지 기능을 점검하기 위한 목적으로 테스트를 작성하는 것은 아니다.
- 테스트를 작성하는 과정을 통해서 나의 코드에 대해 빠르게 피드백을 받을 수 있을 뿐만 아니라 학습 도구로도 활용할 수 있다.
- 이런 경험을 통해 테스트에 대해 어떤 유용함을 느꼈는지 알아본다.

## 가장 작은 단위부터 테스트하기

- 전체 게임 진행 코드부터 테스트를 작성하려 하면 어려울 뿐 아니라, UI까지 테스트 방법을 고민해야 한다.
- 커다란 기능보다는 작은 단위, 예를 들어 Car 객체 같은 가장 작은 단위부터 테스트를 시작한다. 이를 통해 테스트를 쉽게 작성할 수 있고, 테스트의 범위를 명확하게 정의할 수 있다.
  
![](https://techcourse-storage.s3.ap-northeast-2.amazonaws.com/7e49e1cd493c47e0a443915369bf6801)

## 단위 테스트하기 어려운 코드를 단위 테스트하기

- 아래 코드는 Random 때문에 Car에 대한 단위 테스트를 하기 힘들다.
    - 테스트하기 어려운 코드에 의존하는 상위 코드들도 모두 테스트하기 어려워진다.
    - 테스트를 통해 신뢰도를 확보할 수 있는 영역이 줄어든다.

![](https://techcourse-storage.s3.ap-northeast-2.amazonaws.com/5638317bd4554ef9b584ca39693ac11d)

```javascript
class Car {
  static FORWARD_CONDITION = 4;
  #name;
  #position;

  constructor(name) {
    this.#name = name;
    this.#position = 0;
  }

  // 도메인
  move(condition) {
    if (condition < Car.FORWARD_CONDITION) {
      return;
    }

    this.#position += 1;
  }

  // UI
  printPosition() {
    console.log(`${this.#name}: ${this.#position}`)
  }
}
```


- 단위 테스트가 가능하도록 리팩터링한다면 어떻게 하는 것이 좋을까?

### 테스트하기 어려운 부분을 분리하기

- 테스트하기 어려운 부분은 분리하고 테스트 가능한 부분을 단위 테스트한다.
- 테스트하기 어려운 부분은 단위 테스트하지 않아도 된다.
- 참고) [메서드 시그니처를 수정하여 테스트하기 좋은 메서드로 만들기](https://tecoble.techcourse.co.kr/post/2020-05-07-appropriate_method_for_test_by_parameter/)

![](https://techcourse-storage.s3.ap-northeast-2.amazonaws.com/377ec8ff8155428faa4070fc4788dffe)

## 테스트를 위한 코드는 프로덕션 코드에서 분리되어야 한다

- 테스트를 통과하기 위해 프로덕션 코드를 변경하거나 테스트에서만 사용되는 로직을 만들지 않는다.
    - 테스트를 위해 # prefix를 바꾸는 경우
    - 테스트 코드에서만 사용되는 메서드

### 테스트 쓰기가 어려워요! 테스트 때문에 구현 코드를 바꿔야 하나요?

- 일단, 테스트 코드 자체가 아직 낯설기 때문인데 기본 문법과 API들에 익숙해지는 것을 먼저 목표로 삼는다.
- 기본적인 사용 자체에 익숙해졌는데도 어렵다면
    - 테스트 코드를 쓰기 위해 억지로 프로덕션 코드를 바꿔야 한다면, 하나의 함수나 객체가 너무 많은 일을 하고 있어 리팩터링이 필요하거나 구조의 변경이 필요하다.
    - 혹은 위에서 살펴본 Random같은 요소때문에 테스트하기 어려운 경우에 해당할 수도 있다. 이 경우에는 최대한 단위 테스트 가능한 영역을 분리해내고, 그 외에는 테스트를 하지 않는다.

## 예외 케이스 테스트하기

- 테스트는 성공하는 케이스뿐만 아니라 예외 케이스도 고려해야 한다. 예외 상황에 대한 테스트를 통해 코드의 신뢰도를 높일 수 있다. 또한, 경계 조건에 대한 테스트는 코드가 예상대로 작동하는지 확인하는 데 중요하다.

```javascript
test("이름은 공백일 수 없다", () => {
    const name = "";
    expect(() => new Car(name)).toThrowError("이름은 공백일 수 없습니다.");
});
```

## 경계 조건 테스트하기

- 자동차의 전진 조건을 모두 테스트해야 할까?
- 테스트는 경곗값을 기준으로 작성한다.
- 예를 들어, '자동차의 이름은 1글자 이상 5글자 이하여야 한다'는 요구사항에 대해 테스트 케이스를 작성할 때
    - 경계 조건은 1글자, 5글자이다.

```javascript
describe("자동차 전진 테스트", () => {
  test("0일 때 전진하지 않음", () => {
    const car = new Car("공원");

    car.move(0);

    expect(car.position).toBe(0);
  });

  test("1일 때 전진하지 않음", () => {
    const car = new Car("공원");

    car.move(1);

    expect(car.position).toBe(0);
  });

  test("2일 때 전진하지 않음", () => {
    const car = new Car("공원");

    car.move(2);

    expect(car.position).toBe(0);
  });

  //...

  test("9일 때 전진", () => {
    const car = new Car("공원");

    car.move(9);

    expect(car.position).toBe(1);
  });
});
```

### cf) parameterized 테스트

- 테스트 코드도 코드이므로 리팩터링을 통해 개선해나가야 한다. 단순히 파라미터의 값만 바뀌는 경우라면 아래와 같이 테스트할 수 있다.
- [Jest each](https://jestjs.io/docs/api#testeachtablename-fn-timeout) API 활용

```javascript
  test.each([0, 1, 2, 3])("전진하지 않는 경우", (condition) => {
    const car = new Car("공원");

    car.move(condition);
    expect(car.position).toBe(0);
  });

  test.each([4, 5, 6, 7, 8, 9])("전진하는 경우", (condition) => {
    const car = new Car("공원");

    car.move(condition);
    expect(car.position).toBe(1);
  });
```

## 단위 테스트가 실패하는 이유는 한 가지여야 한다

- 단위 테스트도 '코드'이다. 함수가 하나의 기능만 하게 하듯이 테스트 케이스에서도 한 가지만 신경쓴다.
- 테스트 코드를 완성한 이후 리팩터링 작업을 거치거나 기능을 추가할 때, 하나의 테스트 케이스가 실패하는 원인은 하나여야 한다. 이는 문제 해결 시 테스트를 통해 어디를 수정해야 하는지 명확하게 알 수 있게 도와 준다. 테스트 케이스는 가능한 한 구체적이고 명확한 목적을 가져야 한다.

# 🛠 도구

## VSCode Debugger 활용하기

- VSCode Debugger를 이용하여 코드 실행 중에 중단점(breakpoint)을 설정하여 변수의 값과 실행 흐름을 관찰할 수 있다. 이는 복잡한 버그를 찾고 해결하는 데 유용하게 사용할 수 있다.

## IDE의 refactor 기능 활용하기

Refactor 기능을 통해 코드의 재구조화를 쉽게 할 수 있다.

- 예를 들어, 메서드 이름 변경이나 코드 조각의 메서드 추출 과정을 자동화할 수 있다.
- 이를 통해 코드의 일관성 유지를 자동화하고, 개발자는 중요한 로직에 집중할 수 있다.

## [grep.app](https://grep.app/)

Grep.app은 전 세계의 공개된 코드를 검색할 수 있는 툴이다. 이를 통해 다양한 코드 스타일과 패턴을 학습할 수 있다.

# 🤔 생각해보기

이번 미션을 통해 얻은 학습 및 경험을 되돌아보며 다음 미션에 적용할 수 있는 나만의 기준을 세워 본다.

- 이번 미션을 통해 어떤 것을 배웠는가?
    - 가장 기억에 남는 시행착오가 있다면?
- 다음 미션에서 적용해볼 나만의 새로운 기준/지침이 있을까?

### 개념과 함께 채우기

1. 함수 선언 방식의 이해
    - 함수 선언문과 함수 표현식의 차이점은 무엇일까?
2. 클래스, 함수 그리고 객체
    - 어떤 경우에 class를 사용하고, 어떤 경우에 일반 객체를 사용할까?
    - class와 함수의 차이는 무엇일까?
3. 비동기 처리의 다양한 접근
    - 비동기 입력을 처리할 때 callback, promise, async/await 중 어떤 것을 활용했고 왜 선택했는지?
    - 비동기 코드의 에러 처리 방법은 어떻게 다를까?
4. 모듈 시스템의 이해
    - require/module.exports와 import/export 의 차이점은 무엇인가?
5. 명령형 VS 선언형 프로그래밍
    - 명령형 프로그래밍과 선언형 프로그래밍의 핵심적인 차이는 무엇인가? 각각의 접근 방식이 주는 장점과 단점은 무엇인가?
    - 실제 개발 시, 어떤 상황에서 명령형 접근 방식이 유리하고, 언제 선언형 접근 방식을 선택하는 것이 좋을까? 구체적인 예시를 들어 설명해 보자.

이 외에도 마주했던 다양한 질문들에 대한 답을 스스로 정리하자 🙂